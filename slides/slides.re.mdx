export { Components } from "./Components";
export { Themes } from "./Themes";

# Testing Angular apps

> The more your tests resemble the way your software is used, the more confidence they can give you.

---

# Our tools

- Vitest
- Angular Testing Library

---

# Why vitest?

- Jest has massive adoption, but...
- It was created in a different context (2014).
  - This was before we had ES6 (ES modules,`let`, `const`, arrow functions, descructuring, spreading, default parameters, variadic functions...)
- Vitest offers compatibility with most of the Jest API and ecosystem libraries.
  - In most projects, it should be a drop-in replacement for Jest.
- It can become a bottleneck.
  - The time to run can increase in proportion to the number of tests.

---

# Why vitest? Developer Experience

- A test runner that uses the same configuration of your app through `vite.config.ts`.
- Vitest provides better DX thanks to the default watch mode using Vite instant Hot Module Reload.
- Jest can become difficult to configure for ES Modules and TypeScript.
- Its support for ESM is _still_ experimental.
- **Who wants to manage a build pipeline for tests?**
  - `tsconfig`, `ts-jest`, `babel`, unstable Node flags like `unstable_mockModule`, etc.

---

# Why vitest? It can be faster

- Vitest uses `esbuild` instead of Babel to bundle tests.
- To mock browser APIs Jest uses `jsdom` by default. Vitest can use `happy-dom`.
  - Warning: `happy-dom` is still missing some APIs.
- Vitest uses Worker threads to run as much as possible in parallel.
  - Jest has `test.concurrent`, but it has been marked as "experimental" for years.
  - Vitest has the same feature to run tests in parallel, and it's stable.
- **Who likes waiting 5-10 minutes (or more) for tests to finish before merging a PR?**

---

# Why (Angular) Testing Library?

> The more your tests resemble the way your software is used, the more confidence they can give you.

- Testing a component's internals is problematic.
- Changing the implementation (but not the interaction and output) of a component **shouldn't** break your tests.

---

# Why ATL? An example

- The user clicks the `Increment` button in a counter component.
- The user expects the counter to go from `0` to `1`.

---

# Why ATL? An example

Internally you may call a simple `increment()` method.

```typescript
class CounterComponent {
  protected increment() {
    this.count.update((c) => c + 1);
  }
}
```

```html
<button (click)="increment()">Increment</button>
```

---

# Why ATL? An example

Internally you may use bitwise operators.

```typescript
class CounterComponent {
  protected increment(n: number) {
    if(n & 1) {
      return increment(n >>> 1) << 1;
    }

    return n | 1;
  }
}
```

---

# Why ATL? An example

Internally you may call a backend API.

```typescript
class CounterComponent {
  protected increment(n: number) {
    this.#countService.post(n).subscribe({ /* ... */});
  }
}
```

---

# Why ATL? An example

Internally you may use AI.

```typescript
await chatModel.invoke(`
Hello Mr. GPT.

Could you kindly ask WolframAlpha
for the result of adding 1 to ${n}?

Thank you very much. (Please don't take my job yet).
`);
```

---

# Why ATL? An example

- The end-user doesn't care what you do internally.
- The user just wants `0` to become `1` when they click `Increment`.
- Users aren't going to find elements with `document.querySelector()` or `XPath` (looking at you, Selenium).
- Users aren't going to "call a method called `increment` once with parameter `n`, where `n` is `0`".
- Most users don't even know what the above is.
- **The user doesn't care, so why would your tests?**

---

# Please don't.

<div style={{ fontSize: '0.4em' }}>
```typescript
describe("CounterComponent",  () => {
  let fixture: ComponentFixture<CounterComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        CounterComponent,
      ],
      schemas: [NO_ERRORS_SCHEMA],
    });
    fixture = TestBed.createComponent(CounterComponent);
  });

  it("should increment the counter on click", () => {
    // run ngOnInit
    fixture.detectChanges();

    const incrementButton = fixture.debugElement.queryAll(By.css("button"))[0];

    incrementButton.triggerEventHandler("click");
    fixture.detectChanges();

    expect(fixture.componentInstance.increment).toHaveBeenCalledTimes(1);
    expect(fixture.componentInstance.increment).toHaveBeenCalledWith(0);

    const counterText = fixture.debugElement.query(By.css("p")).nativeElement.textContent;
    expect(counterText).toContain("Current count: 1");
  });
})
```
</div>

---

# This is better

> The more your tests resemble the way your software is used, the more confidence they can give you.

<div style={{ fontSize: '0.8em' }}>
```typescript
test("should increment the counter on click", async () => {
  await render(CounterComponent);

  fireEvent.click(screen.getByText("Increment"));

  expect(screen.getByText("Current count: 1")).toBeInTheDocument();
});
```
</div>

---

# I mean it, please don't.

The counter was just a simple example.

<div style={{fontSize: "0.25em", display: 'flex', justifyContent: 'space-between'}}>
  <div>
```typescript
describe("HeroesComponent", () => {
  let fixture: ComponentFixture<HeroesComponent>;
  let mockHeroService;
  let HEROES;

  beforeEach(() => {
    HEROES = [
      { id: 1, name: "SpiderDude", strength: 8 },
      { id: 2, name: "Wonderful Woman", strength: 24 },
      { id: 3, name: "SuperDude", strength: 55 },
    ];
    mockHeroService = jasmine.createSpyObj(["getHeroes", "addHero", "deleteHero"]);

    TestBed.configureTestingModule({
      declarations: [
        HeroesComponent,
        HeroComponent,
      ],
      providers: [{ provide: HeroService, useValue: mockHeroService }],
      schemas: [NO_ERRORS_SCHEMA],
    });
    fixture = TestBed.createComponent(HeroesComponent);
  });

  it("should render each hero as a HeroComponent", () => {
    mockHeroService.getHeroes.and.returnValue(of(HEROES));
    // run ngOnInit
    fixture.detectChanges();

    const heroComponentDebugElements = fixture.debugElement.queryAll(By.directive(HeroComponent));
    expect(heroComponentDebugElements.length).toEqual(3);

    for (let i = 0; i < heroComponentDebugElements.length; i += 1) {
      expect(heroComponentDebugElements[i].componentInstance.hero).toEqual(HEROES[i]);
    }
  });
```
  </div>
  <div>
```typescript
  it("should call heroService.deleteHero when the Hero Component's delete button is clicked", () => {
    spyOn(fixture.componentInstance, "delete");
    mockHeroService.getHeroes.and.returnValue(of(HEROES));

    // run ngOnInit
    fixture.detectChanges();

    const heroComponents = fixture.debugElement.queryAll(
      By.directive(HeroComponent),
    );
    heroComponents[0].triggerEventHandler("delete");

    expect(fixture.componentInstance.delete).toHaveBeenCalledWith(HEROES[0]);
  });

  it("should add a new hero to the list when add button is clicked", () => {
    mockHeroService.getHeroes.and.returnValue(of(HEROES));

    // run ngOnInit
    fixture.detectChanges();

    const name = "Mr Freeze";
    mockHeroService.addHero.and.returnValue(of({ id: 5, name, strength: 4 }));

    const inputElement = fixture
      .debugElement
      .query(By.css("input"))
      .nativeElement;
    const addButton = fixture.debugElement.queryAll(By.css("button"))[0];

    inputElement.value = name;
    addButton.triggerEventHandler("click");
    fixture.detectChanges();

    const heroText = fixture.debugElement.query(By.css("ul")).nativeElement.textContent;
    expect(heroText).toContain(name);
  });
});
```
  </div>
</div>

---

# The 2 testing users

1. The end-user who interacts with our app (clicking buttons, etc.)
2. The developer user who uses our code (rendering it, calling our functions, etc.)

- You want to avoid the Test User.
- This user creeps in when you test implementation details.
  - Internal things which your developer user and end user don't know or care about.
- Remember, the test user doesn't pay the bills.

---

# General guidelines

- **Don't** test implementation details
  - The more your tests resemble the way your software is used, the more confidence they can give you.
- Tests should behave like the application's user
- Itâ€™s important to **clean up before each** test

---

# ATL niceties

- ATL abstracts the boilerplate of creating DOM nodes and appending them to the body
- Its `render` function internally creates a container`<div />` for us and automatically cleans up

---

# Avoid implementation details: TL;DR

- Use `screen.getBy*` queries instead of stuff like `container.firstChild`.
  - Because if you change your HTML markup, **your tests will break**.
- For example, when wrapping a button in a `<span>,` the button will no longer be the first child.
- The user doesn't even know or care when you make these types of HTML changes.
  - We should write our tests in a way that passes in either case.

---

# Avoid implementation details: TL;DR

- Use `userEvent` instead of `fireEvent`.
- `fireEvent` fires a single event.
- A real user fires multiple events.
- This is what `userEvent` emulates.

---

# Avoid implementation details: TL;DR

<div style={{fontSize: '0.8em'}}>
- For example, clicking a button also fires
  - `mouse move` and `mouse leave` if another element was focused
  - `mouse over`
  - `mouse move`
  - `mouse down`
  - if another element was focused it will fire `blur`
  - the clicked element will fire `focus`
  - `mouse up`
  - and finally, `click`
- [ Click implementation in `userEvent`](https://github.com/testing-library/user-event/blob/1af67066f57377c5ab758a1215711dddabad2d83/src/index.js#L109)
</div>

---

<Center>
`code/src/app/counter/counter-test-01.test.ts`
</Center>

---

# Avoid implementation details: Guidelines

- "Implementation details" refers to how an abstraction accomplishes an outcome.
- They are things that users of your code will not typically use, see, or even know about.

---

# Avoid implementation details: Guidelines

- The users don't care about the implementation of your abstractions.
- If you want confidence that your app continues to work through refactors, then neither should your tests care about implementations.

---

# Avoid implementation details: Guidelines

- Tests that care about implementation details:
- Can break when you refactor application code: False negatives.
  - E.g., by renaming `increment` to `updateCount`.
- May not fail when you break application code: False positives.
  - E.g., by making a typo in my `<button>`'s `click` assignment.

---

# Testing forms

- Ensure that the user can:
  - Find inputs.
  - Fill their information.
- Validate the submitted data is correct.

---

# Testing forms: Generate test data

- Communicate in your tests what's essential and what is not.
- **Hard-coding values does NOT communicate this well.**
- Does the code behave differently when the `username` is `ash_ketchum`?
- Do we have particular logic around that?
  - We'd need to look at the implementation to be entirely sure.

---

# Testing forms: Passing overrides to test data generators

- Sometimes, we need to use specific test values.
- For example, if a signup form validates the password strength, we might want to pass a specific password to test it.

---

# Testing forms: Tools to generate test data

- Use `@faker-js/faker` to generate random fake data.
- Combine it with `test-data-bot` by `@jackfranklin` to:
  - Create test data _builders_ (AKA _factories_).
  - Pass overrides.

---


# Using overrides in `@jackfranklin/test-data-bot`

<div style={{fontSize: '0.8em'}}>
```typescript
const buildSignupForm = build<SignupFormValues>({
  fields: {
    username: perBuild(() => faker.internet.userName()),
    password: perBuild(() => faker.internet.password()),
  },
});

const { username, password } = buildSignupForm.one({
  overrides: {
    password: '9EY7x3C9',
  },
});
```
</div>

---

<Center>
  `code/src/app/login-template-driven/login-template-driven-test-02.test.ts`
</Center>

---

<Center>
  `code/src/app/login-reactive/login-reactive-test-03.test.ts`
</Center>

---

# Testing forms

Since we're not testing implementation details, the same test works for template-driven and reactive forms.

![They're the same picture](samepic.jpg?height=30vh&borderRadius=20px)

---

# Testing HTTP requests

- Setting up an environment to test with a real HTTP backend API is not trivial.
- This is one of the responsibilities of E2E tests, using tools like Playwright or Cypress.
- For integration and unit tests, we'll trade off some confidence for convenience.
- Create a mock server with MSW.
- MSW doesn't create an actual server. It uses a Service Worker to intercept requests and return any response we want.

---

# Testing HTTP requests

- You can use MSW during development, too. Not only for tests.
- For example, to develop against an API that is not yet ready
- Or to develop against an external API that isn't currently available.
- You can import and reuse the same HTTP `handlers` during development and in tests.

---

# Testing HTTP requests

- Use `waitForElementToBeRemoved` to wait for loading indicators to go away.
- Test unhappy paths too.
  - What happens if the response to our request is an error?

---

# Use toMatchInlineSnapshot() for error messages

- Copy-pasting output into assertions is not reliable.
  - For example, error messages may change in the future.
- Inline snapshots are written **automatically** back into the source code.

---

# Use toMatchInlineSnapshot() for error messages: example

Look at this test, before running it for the first time.

<div style={{fontSize: '0.75em'}}>
```typescript
test("omitting the password results in an error", async () => {
  /* ... */
  expect(screen.getByRole("alert").textContent).toMatchInlineSnapshot();
});
```
</div>

---

# Use toMatchInlineSnapshot() for error messages: example

After running the test, a text snapshot is added inline:

<div style={{ fontSize: '0.75em' }}>
```typescript
test("omitting the password results in an error", async () => {
  /* ... */
  expect(screen.getByRole("alert").textContent).toMatchInlineSnapshot(
    `" password required "`,
  );
});
```
</div>

---

# Use toMatchInlineSnapshot() for error messages: example

- If the message changes, the test fails.
- If you didn't expect this change, you are now aware of it and can fix your code.
- If the change is correct, you can update the snapshot by removing the previous snapshot and re-running the test.

---

# Use one-off server handlers

- To test any situations where the server can fail.
  - E.g., `500` server errors.
- Write them directly in the test that needs it:
  - To avoid cluttering the application-wide handlers.
  - To avoid confusing developers by having a one-off handler in another place.
- Use msw's `server.use()`.
- Use `server.resetHandlers()` in `afterEach()`.

---

# TODO

- what to mock
- `act` notes
- tips notes
- testing playground extension

---

Made with [ReMDX](https://github.com/nkzw-tech/remdx)
