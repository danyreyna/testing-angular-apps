export { Components } from "./Components";
export { Themes } from "./Themes";

# Testing Angular apps

> The more your tests resemble the way your software is used, the more confidence they can give you.

---

# Our tools

- Vitest
- Angular Testing Library

---

# Why vitest?

- Jest has massive adoption, but...
- It was created in a different context (2014).
  - This was before we had ES6 (ES modules,`let`, `const`, arrow functions, descructuring, spreading, default parameters, variadic functions...)
- Vitest offers compatibility with most of the Jest API and ecosystem libraries.
  - In most projects, it should be a drop-in replacement for Jest.
- It can become a bottleneck.
  - The time to run can increase in proportion to the number of tests.

---

# Why vitest? Developer Experience

- A test runner that uses the same configuration of your app through `vite.config.ts`.
- Vitest provides better DX thanks to the default watch mode using Vite instant Hot Module Reload.
- Jest can become difficult to configure for ES Modules and TypeScript.
- Its support for ESM is _still_ experimental.
- **Who wants to manage a build pipeline for tests?**
  - `tsconfig`, `ts-jest`, `babel`, unstable Node flags like `unstable_mockModule`, etc.

---

# Why vitest? It can be faster

- Vitest uses `esbuild` instead of Babel to bundle tests.
- To mock browser APIs Jest uses `jsdom` by default. Vitest can use `happy-dom`.
  - Warning: `happy-dom` is still missing some APIs.
- Vitest uses Worker threads to run as much as possible in parallel.
  - Jest has `test.concurrent`, but it has been marked as "experimental" for years.
  - Vitest has the same feature to run tests in parallel, and it's stable.
- **Who likes waiting 5-10 minutes (or more) for tests to finish before merging a PR?**

---

# Why (Angular) Testing Library?

> The more your tests resemble the way your software is used, the more confidence they can give you.

- Testing a component's internals is problematic.
- Changing the implementation (but not the interaction and output) of a component **shouldn't** break your tests.

---

# Why ATL? An example

- The user clicks the `Increment` button in a counter component.
- The user expects the counter to go from `0` to `1`.

---

# Why ATL? An example

Internally you may call a simple `increment()` method.

```typescript
class CounterComponent {
  protected increment() {
    this.count.update((c) => c + 1);
  }
}
```

```html
<button (click)="increment()">Increment</button>
```

---

# Why ATL? An example

Internally you may use bitwise operators.

```typescript
class CounterComponent {
  protected increment(n: number) {
    if(n & 1) {
      return increment(n >>> 1) << 1;
    }

    return n | 1;
  }
}
```

---

# Why ATL? An example

Internally you may call a backend API.

```typescript
class CounterComponent {
  protected increment(n: number) {
    this.#countService.post(n).subscribe({ /* ... */});
  }
}
```

---

# Why ATL? An example

Internally you may use AI.

```typescript
await chatModel.invoke(`
Hello Mr. GPT.

Could you kindly ask WolframAlpha
for the result of adding 1 to ${n}?

Thank you very much. (Please don't take my job yet).
`);
```

---

# Why ATL? An example

- The end-user doesn't care what you do internally.
- The user just wants `0` to become `1` when they click `Increment`.
- Users aren't going to find elements with `document.querySelector()` or `XPath` (looking at you, Selenium).
- Users aren't going to "call a method called `increment` once with parameter `n`, where `n` is `0`".
- Most users don't even know what the above is.
- **The user doesn't care, so why would your tests?**

---

# Please don't.

<div style={{ fontSize: '0.4rem' }}>
```typescript
describe("CounterComponent",  () => {
  let fixture: ComponentFixture<CounterComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [
        CounterComponent,
      ],
      schemas: [NO_ERRORS_SCHEMA],
    });
    fixture = TestBed.createComponent(CounterComponent);
  });

  it("should increment the counter on click", () => {
    // run ngOnInit
    fixture.detectChanges();

    const incrementButton = fixture.debugElement.queryAll(By.css("button"))[0];

    incrementButton.triggerEventHandler("click");
    fixture.detectChanges();

    expect(fixture.componentInstance.increment).toHaveBeenCalledTimes(1);
    expect(fixture.componentInstance.increment).toHaveBeenCalledWith(0);

    const counterText = fixture.debugElement.query(By.css("p")).nativeElement.textContent;
    expect(counterText).toContain("Current count: 1");
  });
})
```
</div>

---

# This is better

> The more your tests resemble the way your software is used, the more confidence they can give you.

<div style={{ fontSize: '0.8rem' }}>
```typescript
test("should increment the counter on click", async () => {
  await render(CounterComponent);

  fireEvent.click(screen.getByText("Increment"));

  expect(screen.getByText("Current count: 1")).toBeInTheDocument();
});
```
</div>

---

# I mean it, please don't.

The counter was just a simple example.

<div style={{fontSize: "0.25rem", display: 'flex', justifyContent: 'space-between'}}>
  <div>
```typescript
describe("HeroesComponent", () => {
  let fixture: ComponentFixture<HeroesComponent>;
  let mockHeroService;
  let HEROES;

  beforeEach(() => {
    HEROES = [
      { id: 1, name: "SpiderDude", strength: 8 },
      { id: 2, name: "Wonderful Woman", strength: 24 },
      { id: 3, name: "SuperDude", strength: 55 },
    ];
    mockHeroService = jasmine.createSpyObj(["getHeroes", "addHero", "deleteHero"]);

    TestBed.configureTestingModule({
      declarations: [
        HeroesComponent,
        HeroComponent,
      ],
      providers: [{ provide: HeroService, useValue: mockHeroService }],
      schemas: [NO_ERRORS_SCHEMA],
    });
    fixture = TestBed.createComponent(HeroesComponent);
  });

  it("should render each hero as a HeroComponent", () => {
    mockHeroService.getHeroes.and.returnValue(of(HEROES));
    // run ngOnInit
    fixture.detectChanges();

    const heroComponentDebugElements = fixture.debugElement.queryAll(By.directive(HeroComponent));
    expect(heroComponentDebugElements.length).toEqual(3);

    for (let i = 0; i < heroComponentDebugElements.length; i += 1) {
      expect(heroComponentDebugElements[i].componentInstance.hero).toEqual(HEROES[i]);
    }
  });
```
  </div>
  <div>
```typescript
  it("should call heroService.deleteHero when the Hero Component's delete button is clicked", () => {
    spyOn(fixture.componentInstance, "delete");
    mockHeroService.getHeroes.and.returnValue(of(HEROES));

    // run ngOnInit
    fixture.detectChanges();

    const heroComponents = fixture.debugElement.queryAll(
      By.directive(HeroComponent),
    );
    heroComponents[0].triggerEventHandler("delete");

    expect(fixture.componentInstance.delete).toHaveBeenCalledWith(HEROES[0]);
  });

  it("should add a new hero to the list when add button is clicked", () => {
    mockHeroService.getHeroes.and.returnValue(of(HEROES));

    // run ngOnInit
    fixture.detectChanges();

    const name = "Mr Freeze";
    mockHeroService.addHero.and.returnValue(of({ id: 5, name, strength: 4 }));

    const inputElement = fixture
      .debugElement
      .query(By.css("input"))
      .nativeElement;
    const addButton = fixture.debugElement.queryAll(By.css("button"))[0];

    inputElement.value = name;
    addButton.triggerEventHandler("click");
    fixture.detectChanges();

    const heroText = fixture.debugElement.query(By.css("ul")).nativeElement.textContent;
    expect(heroText).toContain(name);
  });
});
```
  </div>
</div>

---

# The 2 testing users

1. The end-user who interacts with our app (clicking buttons, etc.)
2. The developer user who uses our code (rendering it, calling our functions, etc.)

- You want to avoid the Test User.
- This user creeps in when you test implementation details.
  - Internal things which your developer user and end user don't know or care about.
- Remember, the test user doesn't pay the bills.

---

# General guidelines

- **Don't** test implementation details
  - The more your tests resemble the way your software is used, the more confidence they can give you.
- Tests should behave like the application's user
- Itâ€™s important to **clean up before each** test

---

# ATL niceties

- ATL abstracts the boilerplate of creating DOM nodes and appending them to the body
- Its `render` function internally creates a container`<div />` for us and automatically cleans up

---

# Avoid implementation details: TL;DR

- Use `screen.getBy*` queries instead of stuff like `container.firstChild`.
  - Because if you change your HTML markup, **your tests will break**.
- For example, when wrapping a button in a `<span>,` the button will no longer be the first child.
- The user doesn't even know or care when you make these types of HTML changes.
  - We should write our tests in a way that passes in either case.

---

# Avoid implementation details: TL;DR

- Use `userEvent` instead of `fireEvent`.
- `fireEvent` fires a single event.
- A real user fires multiple events.
- This is what `userEvent` emulates.

---

# Avoid implementation details: TL;DR

<div style={{fontSize: '0.8rem'}}>
- For example, clicking a button also fires
  - `mouse move` and `mouse leave` if another element was focused
  - `mouse over`
  - `mouse move`
  - `mouse down`
  - if another element was focused it will fire `blur`
  - the clicked element will fire `focus`
  - `mouse up`
  - and finally, `click`
- [ Click implementation in `userEvent`](https://github.com/testing-library/user-event/blob/1af67066f57377c5ab758a1215711dddabad2d83/src/index.js#L109)
</div>

---

<Center>
`code/src/app/counter/counter-test-01.test.ts`
</Center>

---

# Avoid implementation details: Guidelines

- "Implementation details" refers to how an abstraction accomplishes an outcome.
- They are things that users of your code will not typically use, see, or even know about.

---

# Avoid implementation details: Guidelines

- The users don't care about the implementation of your abstractions.
- If you want confidence that your app continues to work through refactors, then neither should your tests care about implementations.

---

# Avoid implementation details: Guidelines

- Tests that care about implementation details:
- Can break when you refactor application code: False negatives.
  - E.g., by renaming `increment` to `updateCount`.
- May not fail when you break application code: False positives.
  - E.g., by making a typo in my `<button>`'s `click` assignment.

---

# Testing forms

- Ensure that the user can:
  - Find inputs.
  - Fill their information.
- Validate the submitted data is correct.

---

# Testing forms: Generate test data

- Communicate in your tests what's essential and what is not.
- **Hard-coding values does NOT communicate this well.**
- Does the code behave differently when the `username` is `ash_ketchum`?
- Do we have particular logic around that?
  - We'd need to look at the implementation to be entirely sure.

---

# Testing forms: Passing overrides to test data generators

- Sometimes, we need to use specific test values.
- For example, if a signup form validates the password strength, we might want to pass a specific password to test it.

---

# Testing forms: Tools to generate test data

- Use `@faker-js/faker` to generate random fake data.
- Combine it with `test-data-bot` by `@jackfranklin` to:
  - Create test data _builders_ (AKA _factories_).
  - Pass overrides.

---

# Using overrides in `@jackfranklin/test-data-bot`

<div style={{fontSize: '0.8rem'}}>
```typescript
const buildSignupForm = build<SignupFormValues>({
  fields: {
    username: perBuild(() => faker.internet.userName()),
    password: perBuild(() => faker.internet.password()),
  },
});

const { username, password } = buildSignupForm.one({
  overrides: {
    password: '9EY7x3C9',
  },
});
```
</div>

---

<Center>
  `code/src/app/login-template-driven/login-template-driven-test-02.test.ts`
</Center>

---

<Center>
  `code/src/app/login-reactive/login-reactive-test-03.test.ts`
</Center>

---

# Testing forms

Since we're not testing implementation details, the same test works for template-driven and reactive forms.

![They're the same picture](samepic.jpg?height=30vh&borderRadius=20px)

---

# Testing HTTP requests

- Setting up an environment to test with a real HTTP backend API is not trivial.
- This is one of the responsibilities of E2E tests, using tools like Playwright or Cypress.
- For integration and unit tests, we'll trade off some confidence for convenience.
- Create a mock server with MSW.
- MSW doesn't create an actual server. It uses a Service Worker to intercept requests and return any response we want.

---

# Testing HTTP requests

- You can use MSW during development, too. Not only for tests.
- For example, to develop against an API that is not yet ready
- Or to develop against an external API that isn't currently available.
- You can import and reuse the same HTTP `handlers` during development and in tests.

---

# Testing HTTP requests

- Use `waitForElementToBeRemoved` to wait for loading indicators to go away.
- Test unhappy paths too.
  - What happens if the response to our request is an error?

---

# Use toMatchInlineSnapshot() for error messages

- Copy-pasting output into assertions is not reliable.
  - For example, error messages may change in the future.
- Inline snapshots are written **automatically** back into the source code.

---

# Use toMatchInlineSnapshot() for error messages: example

Look at this test, before running it for the first time.

<div style={{fontSize: '0.75rem'}}>
```typescript
test("omitting the password results in an error", async () => {
  /* ... */
  expect(screen.getByRole("alert").textContent).toMatchInlineSnapshot();
});
```
</div>

---

# Use toMatchInlineSnapshot() for error messages: example

After running the test, a text snapshot is added inline:

<div style={{ fontSize: '0.75rem' }}>
```typescript
test("omitting the password results in an error", async () => {
  /* ... */
  expect(screen.getByRole("alert").textContent).toMatchInlineSnapshot(
    `" password required "`,
  );
});
```
</div>

---

# Use toMatchInlineSnapshot() for error messages: example

- If the message changes, the test fails.
- If you didn't expect this change, you are now aware of it and can fix your code.
- If the change is correct, you can update the snapshot by removing the previous snapshot and re-running the test.

---

# Use one-off server handlers

- To test any situations where the server can fail.
  - E.g., `500` server errors.
- Write them directly in the test that needs it:
  - To avoid cluttering the application-wide handlers.
  - To avoid confusing developers by having a one-off handler in another place.
- Use msw's `server.use()`.
- Use `server.resetHandlers()` in `afterEach()`.

---

<Center>
  `code/src/app/login-submission/login-submission-test-04.test.ts`
</Center>

---

# What to mock? Some examples

- **Payment** processors.
- **Network** calls in unit and integration tests.
- **Browser** APIs that `jsdom` can't simulate. Like the Geolocation API.
- **Disk** operations. Mock node's `fs` module.
- **Animation** libraries to avoid waiting for animations before elements are removed from the page.
- Remember, when mocking, you trade confidence for convenience.
  - Which is why e2e tests are important.

---

# When NOT to mock

- Don't mock to save a few milliseconds per test.
- Don't shallow render to save a few milliseconds.
- If it takes too long to render your component tree:
  - Then you don't have problems to fix in your test.
  - You have a performance issue in your app.

---

# Mocking Browser APIs

- Vitest/Jest uses tools like `jsdom` to simulate a browser environment in node.
- But it's still not capable of simulating things like:
  - window resize
  - geolocation
  - media queries
- For this, you have to mock `window.resizeTo`, `window.navigator.geolocation.watchPosition`, and `window.matchMedia` respectively.

---

# Mocking Browser APIs

- Why simulate a browser in node? Because existing test tools are faster and more capable when run in node.
- But
  - If you're testing something that heavily relies on:
    - browser APIs
    - layout (like drag and drop)
  - Then it's better to test that in a real browser with Playwright or Cypress.

---

<Center>
  `code/src/app/location/location-test-05.test.ts`
</Center>

---

# When to mock modules?

- Mock modules when a module interacts with things that are too hard to mock.
  - For example, if a module interacts with a browser API that is difficult to mock, like `canvas`.
- Mock modules when you want to rely on the module's own tests
  - I.e. on the tests from the library you're using.

---

# Mocking modules: example

- Call `vi.mock` with a module's path and provide a mocked implementation for the values this module exports.
- Everytime we import from this path, we'll get the mock instead.
- `vi.mock` will always be executed before all imports.

---

# Mocking modules: example

<div style={{ fontSize: '0.6rem' }}>
```typescript
// payment.ts
// pretend we get this from a service that knows how much money we currently have
let inWallet = Math.random() * 10_000;

async function callPaymentProcessor() {}

async function getBalance() {
  return inWallet;
}

async function deductPrice(price: number) {
  inWallet -= price;
}

export async function pay(price: number) {
  await callPaymentProcessor();

  await deductPrice(price);

  return await getBalance();
}
```
</div>

---

# Mocking modules: example

<div style={{ fontSize: '0.55rem' }}>
```typescript
// shop-form.ts
import { pay } from "./payment";

const BIKE_COST = 1_000;

export async function buyBike() {
  return await pay(BIKE_COST);
}

// shop-form.test.ts
import { expect, test, vi } from "vitest";
import { buyBike } from "./shop-form";

vi.mock("./payment", () => ({
  pay: vi.fn(() => 9_000),
}));

test("after buying a bike we have a 9,000 balance", async () => {
  const balance = await buyBike();

  expect(balance).toEqual(9_000);
});
```
</div>

---

# Mock only parts of a module

<div style={{ fontSize: '0.7rem' }}>
- Call `vi.importActual('some-path')`
- Spread the imported members.
- Override and mock what you need to.

```typescript
import { vi } from "vitest";

vi.mock("./math", async () => {
  const actualMath = await vi.importActual<typeof import("./math")>("./math");
  return {
    ...actualMath,
    subtract: vi.fn(),
  };
});
```
</div>

---

# Mock modules: `vi.hoisted`

- `vi.hoisted` runs **once** before everything else in the file.
- `vi.mock` runs **once** after `vi.hoisted`, but before everything else.

---

# Angular: mocking services vs mocking modules

- In TypeScript, where most things are just functions, objects, and primitive variables, to use them, you import them from another ES Module, and that's it.
- Since Angular makes extensive use of dependency injection, mocking modules isn't really worth it.
- You end up adding too much code in your test to achieve the same result as if you mocked services directly.

---

# Angular: mocking services vs mocking modules

- To mock modules in Angular you have to:
  - Mock the injected services when you mock the module.
  - Pass these mocked services to `componentProviders` when you call `render`.
  - Hoist these mocks to be able to use them both in `vi.mock`, and in your tests (outside of `vi.mock`).
  - If your mocks are stateful (like when mocking an `Observable` with a `Subject`), reset your mocks in `afterEach`.

---

# Angular: mocking services vs mocking modules

- **In Angular, prefer mocking services directly instead of mocking modules.**
- **Tip:** If the service is or `extends` an `Observable`, mock it with a `Subject`.

---

<Center>
  `code/src/app/location/location-test-06.test.ts`
</Center>

---

<Center>
  `code/src/app/location/location-test-07.test.ts`
</Center>

---

<Center>
  `code/src/app/location/location-test-08.test.ts`
</Center>

---

# Testing with component providers and adding a custom render method

- Remember, write tests that resemble the way our software is used.
- We want to render our components with all common providers, like the ones for:
  - Router
  - Http client
  - Language
  - Theme

---

# Testing with component providers and adding a custom render method

- Passing the providers in every test when calling `render` is annoying.
- Instead, create a custom `render` method that does this automatically.

---

# Testing with component providers and adding a custom render method: How-to

- Create your custom `render` method in a `tests/utils.ts` module.
  - It should include your app providers in `providers`.
- Re-export the rest from Angular Testing Library.

---

<Center>
  `code/src/app/some-button/some-button-test-09.test.ts`
</Center>

---

# Testing services

- Remember, "the more your tests resemble the way your software is used, the more confidence they can give you".
- Where is your service used? It's used in a component.
- That's how we should test most services.
- Often, the easiest way to test a service is to create a component that uses it, and test that component instead.

---

# Testing services

- Simple services should be covered by your component tests.
- But a service should have its own tests if:
  - The service is complex.
  - The service is highly reusable. Like a library you'd publish to npm.
  - The example component you'd write to test the service, is non-trivial.
  - The service has many use cases. So you end up writing a lot of example components to test.
  - To test the service, you want to "re-render" the component that's using it, with different inputs.

---

# Testing services: Caveats

- Services are NOT pure.
  - Services commonly perform side-effects.
  - By changing state or doing I/O operations.
- This means the return values and state of services may be changed by the service's own methods or by external dependencies.
- Because services aren't pure, you can't just call them once and assert the output.

---

# Test simple services

- Write an example test component that uses the service
- Render, interact with, and test that component.

---

# Test complex services: Use the `renderService` utility

- It creates a temporal component that doesn't have any UI associated with it.
- The service is injected in this component.
- The temporal component is rendered.
- It returns the injected service's instance to interact with it directly.

---

<Center>
  `code/src/app/counter-service/counter-service-test-10.test.ts`
</Center>

---

# Extra tip 1: `screen.debug()`

Call `screen.debug();` in a `test` to visualize the rendered HTML.

---

# Extra tip 2: `screen.getByRole("any string here")`

- Call `screen.getByRole("whatever");` in a `test` to log a warning that lists all available roles.
- These roles can be used to get elements.

---

# Extra tip 3: Testing Playground extension

- Point and click elements to know which Testing Library queries to use in your tests.
- [Get the extension](https://chromewebstore.google.com/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano)

---

# Extra tip 4: Article "Common Testing Library mistakes"

- The examples are for React but the same tips apply to Angular Testing Library.
- [Go to the article](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

---

# Extra tip 5: Testing Library query methods guide

## `getByRole` with the `name` option

<div style={{fontSize: '0.8rem'}}>
- For example, `getByRole('button', {name: /submit/i})`
- This method should be your top preference.
- There's not much you can't get with this.
  - If you can't, your UI may not be accessible.
- It uses HTML [roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#roles)
</div>

---

# Extra tip 5: Testing Library query methods guide

## `getByText`

- Use for non-interactive elements.
  - For example, `<div>`, `<span>`, and `<p>`
- Text content is the main way users find elements.

---

# Extra tip 5: Testing Library query methods guide

## `getByLabelText` and `getByDisplayValue`

- Use `getByLabelText` to get form `<input>`s, `<textarea>`s, and `<select>`s.
- `getByDisplayValue` is an alternative way to get these elements if they have a certain value.

---

# Extra tip 5: Testing Library query methods guide

## `query*` methods

<div style={{fontSize: '0.7rem'}}>
- Use them to **verify that an element is not present**.
- The difference between this and `get*` is that if no element is found `get*` throws.
- On the other hand `query*` returns `null`.
- Examples:
  - `await waitForElementToBeRemoved(() => screen.queryByLabelText(/loading/i));`
  - `expect(screen.queryByLabelText(/loading/i)).not.toBeInTheDocument();`
</div>

---

# Extra tip 5: Testing Library query methods guide

## `find*` methods

<div style={{ fontSize: '0.7rem' }}>
- Use them when you want to get an element that may not be available right away.
- These methods try to get the specified element a couple of times until a `timeout` is reached.
- If nothing is found, these methods throw.
- They accept the `waitFor()` method options as the last argument.
  - So you can pass a custom `interval` and `timeout`, among other options.
- Example: `const submitButton = await screen.findByRole('button', {name: /submit/i})`
</div>

---

# Use Case coverage > Code coverage

- Test use cases instead of code.
- Use cases resemble the way users use the app.
- The **code coverage** report can help us identify **use cases** that we're **not covering**.
- But again, don't think in terms of testing code.

---

# Don't bother targeting a 100% code coverage report

- It's not worth the time for apps.
- **But for shared modules** it might be appropriate because:
  - They're generally easier to keep at 100%.
  - Because they're smaller and more isolated.
  - They're important due to the fact that they're shared in multiple projects.

---

# Why so much disdain for code coverage targets?

<div style={{fontSize:'0.8rem'}}>
## What code coverage is telling you:

"This code ran when your tests ran."

## What code coverage is NOT telling you

- "This code will work according to the business requirements."
- "This code works with all the other code in the application."
- "The application cannot get into a bad state."
</div>

---

# Why so much disdain for code coverage targets? An example

- You can increase your code coverage just as much by adding tests to your "About us" page.
- As you can by adding tests to your "Checkout" page.
- One of those things is more important than the other.
- And code coverage can't give you any insight into that for your codebase.

---

# Types of tests

- When painting, there are different brushes for different use cases.
- The same thing applies to tests.
- Spoiler: You should **mostly** write **integration** tests.

---

# Types of tests: E2E

- These will run the entire application.
- **Both frontend and backend.**
- Your test will interact with the app just like a typical user would.
- These tests are written with Playwright or Cypress.
- Confidence level: 4.
- Convenience level: 1.

---

# Types of tests: Integration

- Verify that **several units work well together**.
- These render with all the providers used in the app.
- The **idea** behind integration tests is to **mock as little as possible**.
- Mostly just mock:
  - Network requests with `MSW`.
  - Animation components. Not need to wait for them in automated tests.
- Confidence level: 3.
- Convenience level: 2.

---

# Types of tests: Unit

- These verify that individual, isolated parts work.
- Utility functions are suitable for unit testing.
- But any code that's heavily relied upon is a good candidate for unit testing.
- **Not everything** needs a unit test.
- Most of your code can be covered by good component/**integration** tests.
- Confidence level: 2.
- Convenience level: 3.

---

# Types of tests: Static analyzers

- Linter.
- Type checker.
- Confidence level: 1.
- Convenience level: 4.

---

# How to start testing? Start with E2E

- Write a **single end-to-end test** to cover the **happy path** most users go through.
- You can cover the most important features with this.
- E2E tests aren't going to give you 100% use case coverage, and that's ok.
- Nor will they give you 100% code coverage, and you should not even record that for E2E tests anyway.

---

# Once you have a few E2E tests in place, start writing...

- **Integration** tests, for the **edge cases** that you are **missing** in your E2E tests.
- **Unit** tests, for the **more complex business logic** that those features are using.
- From there it becomes a matter of adding tests over time.

---

# AHA programming

- AHA means [Avoid Hasty Abstractions](https://kentcdodds.com/blog/aha-programming)
- TL;DR: You're not a fortune teller. Be pragmatic.
- We could spend weeks:
  - Coming up with the best API for our new abstraction
  - Or optimizing code for performance
- Only to find out the next day that **we made incorrect assumptions** and the API needs a complete rework or the feature the code was written for is no longer needed.

---

# AHA programming

- Prefer duplication until you feel pretty confident that you know the use cases for that duplicated code.
- After you've got a few places where that code is running, **the commonalities will scream at you for abstraction** and you'll be in the right frame of mind to provide that abstraction.
- On the other hand, if you abstract early, you'll think the function or component is perfect for your use case.
  - But then you just bend the code to fit your new upcoming use cases.
  - And you repeat this until your abstraction is **huge** and has a **lot of conditional** `if`/`switch` statements.

---

# AHA testing

- The point is to **improve readability**.
- It takes less work to write and maintain tests that have mindful abstractions applied to them.
- You want to make the tests easy for developers to understand.
- So they can work out what's happening when a test fails.

---

# Testing without abstractions

- Absolutely No Abstraction (ANA) testing makes reading and understanding tests difficult.
- Look at this [example](https://github.com/kentcdodds/kentcdodds.com/blob/main/content/blog/aha-testing/index.mdx#L54)
- In both we create mocked `req` and `res` objects, and a mocked `next` function.
- Then we do the specific assertions for each test case.
- How easy is it to quickly determine:
  - the difference between these two similar tests
  - and what causes that difference?
- Not so much.

---

# Testing without abstractions: how does this happen?

- John Doe needs to add a test.
- John copies a previous test similar to what he needs.
- John modifies this test a little bit.

---

# DRY testing

- "Don't repeat yourself" testing makes tests difficult to maintain.

## How does this happen?

- John Doe needs to add a test.
- John goes to the testing abstraction.
- John adds another if statement with the case he wants to test.

---

# DRY testing

- DRY testing also leads to:
  - The overuse of `describe` and `it` nesting.
  - And the overuse of `beforeEach`.
- The more you nest and use shared variables between tests, the harder it is to follow the logic.

---

# AHA testing

- Guideline: add abstractions when duplication becomes obvious.
- By adding mindful abstractions we make it clear what's relevant in the arrangements and assertions of tests.
- This leads to more readable tests which are easier to maintain.

---

# AHA testing: How to

- Create a "Test Object Factory" function.
  - It's a function that returns some object you need to create in multiple tests, and it allows to pass overrides.
  - They reduce duplication **and** help communicate what's important in tests.
  - In our previous test example, it's easier to say: "Give me a normal `req` object, but I want it to have these specific properties, because these are **important to the current test**".
- Or create any other helper function.
- Or create state object constants.

---

# AHA testing example: Create a "Test Object Factory" function

<div style={{fontSize:'0.38rem', display: 'flex'}}>
  <div>
```typescript
import * as blogPostController from "../blog-post";

// load the application-wide mock for the database.
jest.mock("../../lib/db");

function setup(overrides = {}) {
  const req = {
    locale: {
      source: "default",
      language: "en",
      region: "GB",
    },
    user: {
      guid: "0336397b-e29d-4b63-b94d-7e68a6fa3747",
      isActive: false,
      picture: "http://placehold.it/32x32",
      age: 30,
      name: {
        first: "Francine",
        last: "Oconnor",
      },
      company: "ACME",
      email: "francine.oconnor@ac.me",
      latitude: 51.507351,
      longitude: -0.127758,
      favoriteFruit: "banana",
    },
    body: {},
    cookies: {},
```
  </div>
  <div>
```typescript
    query: {},
    params: {
      bucket: "photography",
    },
    header(name) {
      return {
        Authorization: "Bearer TEST_TOKEN",
      }[name];
    },
    ...overrides,
  };

  const res = {
    clearCookie: jest.fn(),
    cookie: jest.fn(),
    end: jest.fn(),
    locals: {
      content: {},
    },
    json: jest.fn(),
    send: jest.fn(),
    sendStatus: jest.fn(),
    set: jest.fn(),
  };
  const next = jest.fn();

  return { req, res, next };
}
```
  </div>
</div>

---

# AHA testing example: Create a "Test Object Factory" function

<div style={{fontSize:'0.38rem'}}>
```typescript
test("lists blog posts for the logged in user", async () => {
  const { req, res, next } = setup();

  await blogPostController.loadBlogPosts(req, res, next);

  expect(res.json).toHaveBeenCalledTimes(1);
  expect(res.json).toHaveBeenCalledWith({
    posts: expect.arrayContaining([
      expect.objectContaining({
        title: "Test Post 1",
        subtitle: "This is the subtitle of Test Post 1",
        body: "The is the body of Test Post 1",
      }),
    ]),
  });
});

test("returns an empty list when there are no blog posts", async () => {
  const { req, res, next } = setup();
  req.user.latitude = 31.230416;
  req.user.longitude = 121.473701;

  await blogPostController.loadBlogPosts(req, res, next);

  expect(res.json).toHaveBeenCalledTimes(1);
  expect(res.json).toHaveBeenCalledWith({
    posts: [],
  });
});
```
</div>

---

# AHA testing example: Create a helper function

<div style={{fontSize:'0.37rem', display: 'flex'}}>
  <div>
```typescript
import { render, screen } from "@testing-library/angular";
import userEvent from "@testing-library/user-event";
import {vi} from "vitest";
import { LoginFormComponent } from "../login-form";

async function renderLoginForm(props) {
  await render(LoginFormComponent);
  const usernameInput = screen.getByLabelText(/username/i);
  const passwordInput = screen.getByLabelText(/password/i);
  const submitButton = screen.getByText(/submit/i);
  return {
    usernameInput,
    passwordInput,
    submitButton,
    changeUsername: (value) => userEvent.type(usernameInput, value),
    changePassword: (value) => userEvent.type(passwordInput, value),
    submitForm: () => userEvent.click(submitButton),
  };
}
```
  </div>
  <div>
```typescript
test("submit calls the submit handler", async () => {
  const handleSubmit = vi.fn();
  const { changeUsername, changePassword, submitForm } = await renderLoginForm({
    onSubmit: handleSubmit,
  });
  const username = "chucknorris";
  const password = "ineednopassword";
  await changeUsername(username);
  await changePassword(password);
  await submitForm();
  expect(handleSubmit).toHaveBeenCalledTimes(1);
  expect(handleSubmit).toHaveBeenCalledWith({ username, password });
});
```
  </div>
</div>

---

# AHA testing example: Create state object constants

<div style={{fontSize: '0.32rem', display: 'flex'}}>
  <div>
```typescript
import { beforeEach, expect, test, vi } from "vitest";
import { AsyncService } from "../services";
import { renderService } from "./tests/utils";

beforeEach(() => {
  vi.spyOn(console, "error");
});

/*
 * Restore mocks in `afterEach` (or `beforeEach`) instead of inside tests.
 * This guarantees test isolation.
 * If a test throws before restoring mocks, this ensures mocks are restored anyway.
 * Vitest automatically does this with the `restoreMocks: true` config.
 */
// afterEach(() => {
//   vi.restoreAllMocks();
// });

function getDeferredPromise() {
  let resolve: (value?: unknown) => void = () => {};
  let reject: (reason?: unknown) => void = () => {};

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });

  return { promise, resolve, reject };
}
```
  </div>
  <div>
```typescript
const defaultState = {
  status: "idle",
  data: null,
  error: null,

  isIdle: true,
  isLoading: false,
  isError: false,
  isSuccess: false,

  run: expect.any(Function),
  reset: expect.any(Function),
  setData: expect.any(Function),
  setError: expect.any(Function),
};

const pendingState = {
  ...defaultState,
  status: "pending",
  isIdle: false,
  isLoading: true,
};

const resolvedState = {
  ...defaultState,
  status: "resolved",
  isIdle: false,
  isSuccess: true,
};

const rejectedState = {
  ...defaultState,
  status: "rejected",
  isIdle: false,
  isError: true,
};
```
  </div>
</div>

---

# AHA testing example: Create state object constants

<div style={{fontSize: '0.235rem', display: 'flex'}}>
  <div>
```typescript
test("calling run with a promise which resolves", async () => {
  const { promise, resolve } = getDeferredPromise();
  const { result } = await renderService(AsyncService);

  expect(result.current).toMatchObject(defaultState);

  const runPromise = result.current.run(promise);

  expect(result.current).toMatchObject(pendingState);

  const resolvedValue = Symbol("resolved value");
  resolve(resolvedValue);
  await runPromise;

  expect(result.current).toMatchObject({
    ...resolvedState,
    data: resolvedValue,
  });

  result.current.reset();
  expect(result.current).toMatchObject(defaultState);
});

test("calling run with a promise which rejects", async () => {
  const { promise, reject } = getDeferredPromise();

  const { result } = await renderService(AsyncService);

  expect(result.current).toMatchObject(defaultState);

  const runPromise = result.current.run(promise);

  expect(result.current).toMatchObject(pendingState);

  const rejectedValue = Symbol("rejected value");
  reject(rejectedValue);
  await runPromise.catch(() => {
    /* prevent the rejected promise from failing the test */
  });

  expect(result.current).toMatchObject({
    ...rejectedState,
    error: rejectedValue,
  });
});
```
  </div>
  <div>
```typescript
test("can specify an initial state", async () => {
  const mockData = Symbol("resolved value");
  const customInitialState = { status: "resolved", data: mockData };

  const { result } = await renderService(AsyncService);

  expect(result.current).toMatchObject({
    ...resolvedState,
    ...customInitialState,
  });
});

test("can set the data", async () => {
  const mockData = Symbol("resolved value");
  const { result } = await renderService(AsyncService);

  result.current.setData(mockData);

  expect(result.current).toMatchObject({
    ...resolvedState,
    data: mockData,
  });
});

test("can set the error", async () => {
  const mockError = Symbol("rejected value");
  const { result } = await renderService(AsyncService);

  result.current.setError(mockError);

  expect(result.current).toMatchObject({
    ...rejectedState,
    error: mockError,
  });
});
```
  </div>
  <div>
```typescript
test("No state updates happen if the component is unmounted while pending", async () => {
  const { promise, resolve } = getDeferredPromise();
  const { result, unmount } = await renderService(AsyncService);

  const runPromise = result.current.run(promise);

  unmount();

  resolve();
  await runPromise;

  expect(console.error).not.toHaveBeenCalled();
});

test('calling "run" without a promise results in an early error', async () => {
  const { result } = await renderService(AsyncService);

  expect(() => result.current.run()).toThrowErrorMatchingInlineSnapshot(
    `"The argument passed to AsyncService.run must be a promise.
    Maybe a function that's passed isn't returning anything?"`,
  );
});
```
  </div>
</div>

---

# Integration testing

- Integration tests strike a great balance on the trade-offs between confidence and speed/expense.
- We should get most of our use case coverage from integration tests (most, not all).
- They give us the most in regards to the level of confidence we can achieve relative to the amount of work they take.

---

# Unit tests vs integration tests

- If you tried to get the same confidence using unit tests, you'd have to write a lot more of them.
- Also, you'll find that you're ultimately doing less work with a handful of integration tests.

---

# Unit tests vs integration tests: mocking

- With unit tests you often mock dependencies.
- With integration tests, you're typically only going to need to mock:
  - HTTP requests.
  - Sometimes third party modules.

---

# Unit tests vs integration tests: coverage

- Often you get the bulk of your coverage from integration tests, and reserve unit tests for:
  - Pure functions of complex logic.
  - Highly reusable code/components.
---

# Integration tests reminder: 100% code coverage is a bad idea

- You get **diminishing returns** on your tests as the coverage increases.
- When you strive for 100% all the time, you find yourself spending time testing things that really don't need to be tested.
- Maintaining tests with this goal slow you and your team down.

---

# Integration tests reminder: avoid testing implementation details

- It doesn't give you very much confidence that your application is working.
- It slows you down when refactoring.
- **You should very rarely have to change tests when you refactor code**.

---

# Integration tests are important

- While having unit tests to verify things work in isolation isn't a bad thing...
- It doesn't do you any good if you don't **also verify that they work together** properly.
- Also, you'll find that by testing that they work together properly, you often don't need to bother testing them in isolation.

---

# Integration tests: Stop mocking

<div style={{fontSize: '0.9rem'}}>
- The biggest thing you can do to write more integration tests is to **stop mocking so much stuff**.
- When you mock something you're removing all confidence in the integration between:
  - What you're testing.
  - And the thing you're mocking.
- Each time you test, you don't actually want to
  - Send emails.
  - Or charge credit cards.
- But most of the time you can avoid mocking and you'll be better off for it.
</div>

---

# Authentication

<div style={{ fontSize: '0.9rem' }}>
- You can set your app into an authenticated state by setting the auth cookie before running tests.
- It works out really nice for integration tests.
- And also allows e2e tests to not have to go through the entire authentication flow each time.

## Authentication providers (e.g. Auth0, AWS Cognito, Azure AD)

- If you use an authentication provider, simulating a logged-in state will be different depending on which one you're using.
- But you'll probably need to mock the JS module you're using to interact with the provider.
</div>

---

# Integration tests: imports

- Normally you shouldn't import anything but:
  - What you're explicitly testing.
  - Test utils.
  - Anything you need for cleanup.
- But there are exceptions:
  - For example, importing some utility function when the alternative approaches are more complicated.

---

# Integration tests: screen-specific utilities

- When testing a screen, if as part of your tests' setup you're doing some things repeatedly that are specific to that screen and not applicable to others.
- It makes sense to create screens-specific testing helpers for it.

---

# TODO

- bookshelf tests 13
- bookshelf tests 14
- get rid of @analogjs deps
- https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated
- use # global paths with node's module config
- slides in dark mode
- eslint and grammar

---

Made with [ReMDX](https://github.com/nkzw-tech/remdx)
